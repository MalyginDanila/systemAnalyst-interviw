1) Чем SOAP отличается от REST?  
	 1. Протокол обмена сообщениями, основан на XML и обычно использует HTTP, но может работать и поверх других протоколов (SMTP, TCP и др.) | Архитектурный стиль для построения распределённых систем, использующий стандартные HTTP-методы (GET, POST, PUT, DELETE) 
	 2. строго XML с определённой структурой (SOAP) | Любой формат: XML, JSON, HTML, текст и др
	 3. Имеет множество стандартов (WS-Security, WS-AtomicTransaction и др.) для безопасности, транзакций и т.п. | Обычно не имеет встроенных стандартов — безопасность и прочие аспекты реализуются отдельно (например, OAuth)
	 4. Обычно без сохранения состояния (stateless), но может быть stateful | Обычно stateless (без сохранения состояния)
	 5. Более сложный и тяжеловесный | Проще и легче для разработки и интеграции
	 6. Предпочтителен в корпоративных системах с высокими требованиями к безопасности и транзакциям | Широко используется в веб-разработке и мобильных приложениях

---

2) Из чего состоит сообщение в SOAP?  
		   SOAP-сообщение — это XML-документ с фиксированной структурой, который включает:
	
	1. Envelope (конверт)
	   Корневой элемент <soap:Envelope>, который определяет сообщение как SOAP-сообщение.
	
	2. Header (заголовок) — необязательный
	   Элемент <soap:Header>, содержит служебную информацию, например, данные аутентификации, маршрутизации, транзакций.
	
	3. Body (тело) — обязательный
	   Элемент <soap:Body>, содержит основное сообщение — запрос или ответ с данными.
	
	4. Fault (ошибка) — внутри Body, необязательный
	   Элемент <soap:Fault>, описывает ошибки при обработке сообщения.
	
	---
	
	Пример простого SOAP-сообщения:
	
	<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
	  <soap:Header>
	    <!-- Заголовок с дополнительной информацией -->
	  </soap:Header>
	  <soap:Body>
	    <m:GetPrice xmlns:m="http://www.example.org/stock">
	      <m:StockName>IBM</m:StockName>
	    </m:GetPrice>
	  </soap:Body>
	</soap:Envelope>

---

3)  Что содержит HEADER в ответе REST?  
		   В REST-запросах и ответах HTTP-заголовки (headers) содержат метаинформацию о сообщении. В частности, в HEADER ответа REST (то есть в HTTP-заголовках ответа сервера) обычно содержится следующая информация:
	
	• Статус ответа — код состояния HTTP (например, 200 OK, 404 Not Found).
	• Content-Type — тип содержимого тела ответа (например, application/json, text/html).
	• Content-Length — длина тела ответа в байтах.
	• Date — дата и время формирования ответа.
	• Cache-Control — правила кэширования.
	• Server — информация о сервере.
	• Location — URL для перенаправления (в ответах с кодами 3xx).
	• ETag — идентификатор версии ресурса для кеширования.
	• Authorization или WWW-Authenticate — данные аутентификации (реже в ответе).
	• Другие кастомные заголовки, которые могут передавать дополнительную информацию.
	
	То есть HEADER в REST-ответе — это набор пар «ключ: значение», которые описывают параметры и свойства самого ответа, но не содержат основное тело данных (payload), которое идет отдельно.

---

4) Чем отличается ошибка 200 от 201?  
	   200 - успешный ответ
	   201 - ресурс создан

---

5) Какие методы REST вы знаете?  
	   GET. POST. PUT. PATCH. OPTIONS. LIST. DELETE

---

6) Чем POST отличается от GET?  
	   GET - запрос информации о ресурсе, не имеет тела, идемпотентен
	   POST - создание нового ресурса, неидемпотентый

---

7) Чем PUT отличается от PATCH?  
	    PUT - обновление ресурса
	    PATCH - частичное обновление

---

8) Что содержит URL в REST запросе?  
	1. Обычно http:// или https://, указывает протокол передачи данных.
	2. Хост Сервер, на котором расположен ресурс, например api.example.com.
	3. Определяет конкретный ресурс или коллекцию ресурсов. Например:  /users/123 — пользователь с ID 123.
		1. Объект api.com/user/{user-id}
		2. Коллекция инициатор-сервер api.com/users
		3. Хранилище инициатор-сервер api.com/files/{file-id}
		4. Контроллер POST api.com/sms-send
	4. Query Передаются после знака ? в формате ключ=значение, могут использоваться для фильтрации, сортировки, пагинации и т.п. Например: ?sort=asc&limit=10

---

9) Как проверить, что сообщение брокера получено в полном объеме?  
	 1. Подтверждение доставки (Acknowledgment)
	   – Клиент (консьюмер) отправляет брокеру подтверждение (ACK) после успешного получения и обработки сообщения. Если подтверждение не приходит, брокер может повторно отправить сообщение.
	   – В некоторых системах есть автоматические и ручные режимы подтверждений.
	
	2. Идентификаторы сообщений и контрольные суммы
	   – Сообщения содержат уникальные ID (offset, message ID), которые позволяют отслеживать последовательность и отсутствие пропусков.
	   – Использование контрольных сумм (checksum, hash) для проверки целостности данных.
	
	3. Проверка размера сообщения
	   – Если известно ожидаемое количество байт, можно сверить размер полученного сообщения с ожидаемым.
	
	4. Использование транзакций или атомарных операций
	   – В некоторых брокерах поддерживаются транзакции, которые гарантируют целостность и полноту передачи.
	
	5. Логирование и мониторинг
	   – Отслеживание метрик доставки, повторных попыток и ошибок.

---

10) Знаете ли вы CAP-теорему?
	невозможно, чтобы распределенная система одновременно обеспечивала все три гарантии:
	
	1. Согласованность или последовательность (C): все клиенты видят одни и те же данные в одно и то же время.
	2. Доступность (A): каждый запрос получает ответ, при этом не гарантируется, что он содержит самые последние данные.
	3. Устойчивость к разделениям (P): система продолжает работать, несмотря на разделение сети, которое может произойти, когда узлы (компоненты распределённой системы) теряют связь друг с другом из-за сбоев в сети (например два сервера потеряли связь между друг другом).

---

11) Что такое stateless и stateful, если говорить про сервисы? Rest – это какие сервисы? Что значит stateless сервисы?  
	Stateful API:
	
	- Сервер запоминает состояние клиента при нескольких запросах. Он хранит информацию о клиенте, такую как предпочтения пользователя, прошлые действия или другие данные, относящиеся к взаимодействию клиента с веб-службой.
	- Преимущества:
	    - Персонализация. Поскольку сервер хранит состояние клиента, он может обеспечить персонализированный пользовательский опыт, основанный на прошлых взаимодействиях клиента.
	    - Более простая навигация. Пользователи могут легко перемещаться между различными частями веб-приложения без необходимости каждый раз заново вводить данные или проходить аутентификацию.
	- Недостатки:
	    - Проблемы масштабируемости. Хранение состояния клиента на сервере потребляет ресурсы и может стать узким местом при увеличении числа клиентов.
	    - Сложность. Управление состоянием клиента на сервере усложняет приложение и делает его более сложным в обслуживании и устранении неполадок.
	- Пример из реального мира: работа с файлами по FTP протоколу — каждое действие клиента регистрируется сервером в состояние и сохраняется на сервере.
	
	Stateless API
	
	- В API без состояния сервер не хранит никакой информации о состоянии клиента между запросами. Каждый запрос должен содержать всю необходимую информацию, чтобы сервер мог его обработать.
	- Преимущества
	    - Масштабируемость. API без статических данных более масштабируемы, так как серверу не нужно хранить и управлять состоянием клиента, освобождая ресурсы.
	    - Простота. Отсутствие управления состоянием на сервере упрощает приложение и облегчает его обслуживание и устранение неполадок.
	- Недостатки:
	    - Меньшая персонализация. API без состояния не обеспечивают такого же уровня персонализации, как API с состоянием, поскольку сервер не запоминает прошлые взаимодействия клиента.
	    - Повышенная сложность на стороне клиента. Клиент должен управлять своим состоянием и включать всю необходимую информацию в каждый запрос, что может увеличить сложность на стороне клиента.
	- Пример из реального мира: API REST, широко используемые в веб-сервисах, как правило, не имеют состояния по своей конструкции. Они полагаются на то, что клиент предоставляет всю необходимую информацию в каждом запросе, позволяя серверу сосредоточиться на обработке запроса без сохранения состояния клиента.

---

12) Что такое идемпотентность? Почем это важно?  
	Идемпотентность - когда на один тот же запрос сервер отвечает одинаково. Необходимо это для уменьшения нагрузки на сервер

---

13) DELETE – идемпотентный метод?  Да

---

14) Что такое синхронные и асинхронные вызовы?  
	1) Синхронные - когда клиент сделал запрос и ждёт ответ от сервера
	2) Асинхронные - когда клиент сделал запрос и может делать ещё что-то, не дожидаясь ответа от сервера

---

15)  Для чего вы использовали брокер сообщений? 
	1) Для проектирования асинхронного взаимодействия
	2) Для механизма миграции из одной бд в другую
	3) Для промежуточного слоя между сервером и БД

---

16) Как брокер сообщений гарантирует доставку сообщений?  
	1. Подтверждения (Acknowledgments)
	   – Получатель (консьюмер) отправляет брокеру подтверждение успешного получения и обработки сообщения. Пока подтверждение не получено, брокер может повторять отправку сообщения (повторная доставка).
	   – В зависимости от настроек, подтверждения могут быть автоматическими или ручными.
	
	2. Хранение сообщений (Persistence)
	   – Сообщения сохраняются на диске или в надежном хранилище, чтобы избежать их потери при сбоях брокера или сети.
	   – Это позволяет восстановить сообщения после перезапуска брокера.
	
	3. Очередь сообщений и порядок доставки
	   – Сообщения ставятся в очередь и доставляются в порядке поступления (или с учетом приоритетов).
	   – Использование уникальных идентификаторов (offset, message ID) помогает отслеживать статус доставки.
	
	4. Политики повторной отправки (Retry/Redelivery)
	   – Если подтверждение не получено, брокер повторяет отправку сообщения через определённые интервалы.
	   – Иногда применяется ограничение по количеству попыток с последующим помещением сообщения в «мертвую» очередь (Dead Letter Queue).
	
	6. Транзакции и атомарные операции
	   – Некоторые брокеры поддерживают транзакционную отправку и получение сообщений, что позволяет гарантировать целостность операций.
	
	7. Мониторинг и логирование
	   – Отслеживание статусов сообщений, ошибок и повторных попыток помогает выявлять проблемы и обеспечивать надежность.

---

17) Чем Kafka отличается от RabbitMQ? 
	1. Архитектура и модель обмена сообщениями
	
	• Kafka
	  – Построен как распределённый журнал (лог) сообщений.
	  – Сообщения записываются в топики, разделённые на партиции.
	  – Консьюмеры читают сообщения по offset’ам, могут читать несколько раз и в любом порядке.
	  – Поддерживает модель публикации-подписки (pub-sub) и потоковую обработку.
	  – Сообщения сохраняются длительно (по умолчанию), что позволяет повторно читать историю.
	
	• RabbitMQ
	  – Основан на модели очередей и маршрутизации (использует протокол AMQP).
	  – Сообщения помещаются в очереди, откуда доставляются потребителям.
	  – Обычно сообщения удаляются из очереди после подтверждения доставки (consume-and-delete).
	  – Поддерживает различные схемы маршрутизации (direct, topic, fanout, headers).
	  – Более ориентирован на традиционную очередь задач.
	
	---
	
	▎2. Гарантии доставки
	
	• Kafka
	  – Гарантирует доставку «как минимум один раз» (at least once), при правильной настройке — «ровно один раз» (exactly once) с использованием транзакций.
	  – Консьюмеры сами контролируют, какой offset они обработали.
	
	• RabbitMQ
	  – Гарантирует доставку «как минимум один раз» через подтверждения сообщений (ack).
	  – Может поддерживать откат сообщений и повторную доставку.
	
	---
	
	▎3. Производительность и масштабируемость
	
	• Kafka
	  – Высокая пропускная способность и низкая задержка при работе с большими потоками данных.
	  – Легко масштабируется горизонтально за счёт партиционирования топиков и кластеризации.
	
	• RabbitMQ
	  – Хорошо подходит для умеренных нагрузок и сложных схем маршрутизации.
	  – Масштабирование возможно, но сложнее в сравнении с Kafka.
	
	---
	
	▎4. Сценарии использования
	
	• Kafka
	  – Потоковая обработка данных (stream processing).
	  – Сбор и анализ логов, метрик.
	  – Интеграция больших распределённых систем.
	  – Хранение событий для последующего анализа.
	
	• RabbitMQ
	  – Обработка задач и очередей заданий (job queues).
	  – Сложная маршрутизация сообщений между сервисами.
	  – Системы с требованием гарантированной доставки и подтверждений.
	
	---
	
	▎5. Протоколы и клиентские библиотеки
	
	• Kafka использует собственный протокол поверх TCP.
	• RabbitMQ поддерживает AMQP (стандартный протокол), а также MQTT, STOMP и др.

---

18) Есть две системы. Назовите все способы интеграции этих систем.  
	1) Удалённый вызов (SOAP. REST. gPRC. graphQL)
	2) Обмен сообщениями (Шина, брокеры)
	3) DBlink
	4) FTP

---

19) Клиент читает в Kafka два последних сообщения. Как тому же клиенту заново прочитать эти два последние сообщения
	    В Kafka клиенты (консьюмеры) читают сообщения, сдвигая свой offset — позицию в партиции топика. Чтобы заново прочитать последние два сообщения, клиенту нужно откатить offset назад на 2 позиции и снова прочитать сообщения.

---

20)  Опишите все способы снизить нагрузку на вебсервис.  
	1. Кэширование
	   – Кэшировать ответы на стороне клиента (HTTP-кэширование, заголовки Cache-Control).
	   – Использовать CDN (Content Delivery Network) для отдачи статического контента.
	   – Кэшировать результаты на сервере (например, Redis, Memcached).
	
	2. Балансировка нагрузки
	   – Распределять запросы между несколькими серверами через load balancer (например, Nginx, HAProxy).
	
	3. Оптимизация кода и базы данных
	   – Оптимизировать SQL-запросы, использовать индексы.
	   – Минимизировать объем передаваемых данных (сжатие, минимизация JSON/HTML).
	   – Асинхронная обработка тяжёлых задач (через очереди, например RabbitMQ, Kafka).
	
	4. Ограничение частоты запросов (Rate limiting)
	   – Защита от DDoS и чрезмерных запросов от одного клиента.
	
	5. Горизонтальное масштабирование
	   – Добавление новых серверов для обработки увеличенного количества запросов.
	
	6. Использование асинхронных вызовов и очередей
	   – Перенос тяжёлых операций в фоновые задачи.
	
	7. Оптимизация конфигурации сервера
	   – Настройка параметров веб-сервера (например, keep-alive, количество воркеров).
	
	8. Сжатие данных
	   – Включение gzip/deflate сжатия для HTTP-ответов.
	
	9. Мониторинг и профилирование
	   – Отслеживание узких мест и своевременное реагирование на рост нагрузки.

---

21) 